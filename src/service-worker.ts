/// <reference lib="WebWorker" />

import { build, files, prerendered, version } from '$service-worker';

/**
 * Service worker global execution context.
 */
const ctx = self as unknown as ServiceWorkerGlobalScope;
const FILES = `cache${version}`;
const IMAGE_CACHE_VER = '1659457045';
const IMAGE_CACHE = `cacheimg${IMAGE_CACHE_VER}`;

const IMAGE_URL = `${self.location.origin}/images/`;

const changelog = [
	'Update timeline', 
	'Fix item list on safari', 
	'Fix summit shaper materials'
];

/**
 * Dictionary of cacheable resources.
 */
const CACHES = new Map([
	[`vite-cache-v${version}`, build],
	[`file-cache-v${version}`, files],
	[`page-cache-v${version}`, prerendered]
]);

// `build` is an array of all the files generated by the bundler,
// `files` is an array of everything in the `static` directory
const to_cache = build.concat(files);
const staticAssets = new Set(to_cache);

/**
 * Determine if resource should be cached.
 */
const cacheable = (resource: string): string | undefined => {
	for (const [name, resources] of CACHES.entries()) {
		if (resources.includes(resource)) {
			return name;
		}
	}
};

/**
 * Cache cacheable resources.
 */
const maybeCache = (request: Request, response: Response) => {
	const name = cacheable(request.url);
	name &&
		caches.open(name).then((cache) => {
			cache.put(request, response.clone());
		});
	return response;
};

/**
 * Install and activate caches.
 */
ctx.addEventListener('install', (evt) => {
	const deferreds = [];
	for (const [name, resources] of CACHES.entries()) {
		deferreds.push(caches.open(name).then((cache) => cache.addAll(resources)));
	}
	evt.waitUntil(Promise.all(deferreds).finally(ctx.skipWaiting));
});

/**
 * Prune caches, preserving only current cache versions.
 */
ctx.addEventListener('activate', (evt) => {
	evt.waitUntil(
		caches.keys().then(async (keys) => {
			// delete old caches
			for (const key of keys) {
				if (key !== FILES) await caches.delete(key);
			}
			
			return Promise.all(
				keys.map((key) => (CACHES.has(key) ? Promise.resolve() : caches.delete(key)))
			);
		})
	);
});

/**
 * Fetch the asset from the network and store it in the cache.
 * Fall back to the cache if the user is offline.
 */
 async function fetchAndCache(request: Request) {
	const cache = await caches.open(`offline${version}`);

	try {
		const response = await fetch(request);
		cache.put(request, response.clone());
		return response;
	} catch (err) {
		const response = await cache.match(request);

		if (response) return response;

		throw err;
	}
}

/**
 * Intercept requests and return cached resources if available.
 */
ctx.addEventListener('fetch', (evt) => {
	if (evt.request.method !== 'GET' || evt.request.headers.has('range')) return;
	const url = new URL(evt.request.url);
	const isHttp = url.protocol.startsWith('http');
	const isDevServerRequest = url.hostname === self.location.hostname && url.port !== self.location.port;
	const isStaticAsset = url.host === self.location.host && staticAssets.has(url.pathname);
	const skipBecauseUncached = evt.request.cache === 'only-if-cached' && !isStaticAsset;

	if (isHttp && !isDevServerRequest && !skipBecauseUncached) {
		evt.respondWith(
			(async ()=> {
				const cachedAsset = isStaticAsset && (await caches.match(evt.request).then((response) => {
					return (
						response ||
						fetch(evt.request).then((res) => {
							return maybeCache(evt.request, res);
						})
					);
				}));
				
				return cachedAsset || fetchAndCache(evt.request);
			})()
		);
	}
});